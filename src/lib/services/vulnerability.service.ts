import { VulnerabilityRepository } from "../repositories/vulnerability.repository";
import { 
  vulnerabilityQuerySchema, 
  createVulnerabilitySchema,
  type CreateVulnerability,
  type Vulnerability,
  type CsvRow
} from "../validators/vulnerability.schema";
import { ValidationError, FileUploadError } from "../errors/AppError";
import { logError } from "../errors/errorHandler";
import * as csv from "csv-parse/sync";

/**
 * Service for vulnerability business logic
 */
export class VulnerabilityService {
  private repository = new VulnerabilityRepository();

  /**
   * Get vulnerabilities with validation and business logic
   */
  async getVulnerabilities(queryParams: Record<string, unknown>) {
    try {
      // Validate query parameters
      const validatedQuery = vulnerabilityQuerySchema.parse(queryParams);
      
      // Fetch data through repository
      const result = await this.repository.findMany(validatedQuery);
      
      return {
        success: true,
        ...result,
      };
    } catch (error) {
      logError(error, "VulnerabilityService.getVulnerabilities");
      
      if (error instanceof ValidationError) {
        throw error;
      }
      
      throw new Error("Failed to fetch vulnerabilities");
    }
  }

  /**
   * Get vulnerability by ID
   */
  async getVulnerabilityById(id: string): Promise<Vulnerability> {
    try {
      return await this.repository.findById(id);
    } catch (error) {
      logError(error, "VulnerabilityService.getVulnerabilityById");
      throw error;
    }
  }

  /**
   * Get vulnerability statistics
   */
  async getVulnerabilityStats() {
    try {
      const stats = await this.repository.getStats();
      return {
        success: true,
        stats,
      };
    } catch (error) {
      logError(error, "VulnerabilityService.getVulnerabilityStats");
      throw new Error("Failed to fetch vulnerability statistics");
    }
  }

  /**
   * Process CSV file upload
   */
  async processUpload(file: File): Promise<{
    success: boolean;
    inserted: number;
    skipped: number;
    errors: string[];
  }> {
    try {
      // Validate file
      if (!file) {
        throw new FileUploadError("No file provided");
      }

      if (file.size > 10 * 1024 * 1024) {
        throw new FileUploadError("File size exceeds 10MB limit");
      }

      if (!file.name.endsWith('.csv') && file.type !== 'text/csv') {
        throw new FileUploadError("File must be a CSV");
      }

      // Parse CSV
      const text = await file.text();
      const records = csv.parse(text, {
        columns: true,
        skip_empty_lines: true,
      }) as CsvRow[];

      if (records.length === 0) {
        throw new FileUploadError("CSV file is empty");
      }

      // Transform and validate data
      const vulnerabilities: CreateVulnerability[] = [];
      const errors: string[] = [];
      let skipped = 0;

      for (let i = 0; i < records.length; i++) {
        try {
          const row = records[i];
          
          // Transform CSV row to vulnerability format
          const vulnerability = this.transformCsvRow(row);
          
          // Validate the transformed data
          const validatedVuln = createVulnerabilitySchema.parse(vulnerability);
          vulnerabilities.push(validatedVuln);
        } catch (error) {
          skipped++;
          errors.push(`Row ${i + 1}: ${error instanceof Error ? error.message : 'Invalid data'}`);
        }
      }

      // Insert valid vulnerabilities
      let inserted = 0;
      if (vulnerabilities.length > 0) {
        const result = await this.repository.createMany(vulnerabilities);
        inserted = result.length;
      }

      return {
        success: true,
        inserted,
        skipped,
        errors: errors.slice(0, 10), // Limit error messages
      };
    } catch (error) {
      logError(error, "VulnerabilityService.processUpload");
      
      if (error instanceof FileUploadError || error instanceof ValidationError) {
        throw error;
      }
      
      throw new FileUploadError("Failed to process CSV file");
    }
  }

  /**
   * Transform CSV row to vulnerability format
   */
  private transformCsvRow(row: CsvRow): CreateVulnerability {
    return {
      ip_address: row["IP Address"] || row["IP"] || "",
      cve: row["CVE"] || row["Plugin ID"] || "",
      severity: this.normalizeSeverity(row["Severity"] || row["Risk"] || "medium"),
      plugin_name: row["Plugin Name"] || row["Name"] || "",
      description: row["Description"] || row["Synopsis"] || "",
    };
  }

  /**
   * Normalize severity values from different formats
   */
  private normalizeSeverity(severity: string): "high" | "medium" | "low" | "info" {
    const normalized = severity.toLowerCase().trim();
    
    if (["critical", "high"].includes(normalized)) return "high";
    if (["medium", "moderate"].includes(normalized)) return "medium";
    if (["low", "minor"].includes(normalized)) return "low";
    if (["info", "informational", "none"].includes(normalized)) return "info";
    
    return "medium"; // Default fallback
  }

  /**
   * Test database connection
   */
  async testConnection(): Promise<{ success: boolean; error?: string }> {
    try {
      const isConnected = await this.repository.testConnection();
      return { success: isConnected };
    } catch (error) {
      logError(error, "VulnerabilityService.testConnection");
      return {
        success: false,
        error: error instanceof Error ? error.message : "Connection test failed"
      };
    }
  }
}
