import { databaseClient } from "../database/client";
import { Vulnerability, CreateVulnerability, VulnerabilityQuery } from "../validators/vulnerability.schema";
import { DatabaseError, NotFoundError } from "../errors/AppError";

/**
 * Repository for vulnerability data access
 */
export class VulnerabilityRepository {
  private client = databaseClient.getClient();

  /**
   * Get all vulnerabilities with pagination and filtering
   */
  async findMany(query: VulnerabilityQuery): Promise<{
    data: Vulnerability[];
    total: number;
    page: number;
    totalPages: number;
  }> {
    try {
      let supabaseQuery = this.client
        .from("vulnerabilities")
        .select("*", { count: "exact" });

      // Apply severity filter
      if (query.severity !== "all") {
        supabaseQuery = supabaseQuery.eq("severity", query.severity);
      }

      // Apply search filter
      if (query.search) {
        supabaseQuery = supabaseQuery.or(
          `ip_address.ilike.%${query.search}%,cve.ilike.%${query.search}%,plugin_name.ilike.%${query.search}%`
        );
      }

      // Apply sorting
      supabaseQuery = supabaseQuery.order(query.sort, { ascending: query.order === "asc" });

      // Apply pagination
      const from = (query.page - 1) * query.limit;
      const to = from + query.limit - 1;
      supabaseQuery = supabaseQuery.range(from, to);

      const { data, error, count } = await supabaseQuery;

      if (error) {
        throw new DatabaseError(error.message);
      }

      const total = count || 0;
      const totalPages = Math.ceil(total / query.limit);

      return {
        data: data || [],
        total,
        page: query.page,
        totalPages,
      };
    } catch (error) {
      if (error instanceof DatabaseError) throw error;
      throw new DatabaseError(`Failed to fetch vulnerabilities: ${error}`);
    }
  }

  /**
   * Get vulnerability by ID
   */
  async findById(id: string): Promise<Vulnerability> {
    try {
      const { data, error } = await this.client
        .from("vulnerabilities")
        .select("*")
        .eq("id", id)
        .single();

      if (error) {
        if (error.code === "PGRST116") {
          throw new NotFoundError("Vulnerability", id);
        }
        throw new DatabaseError(error.message);
      }

      return data;
    } catch (error) {
      if (error instanceof NotFoundError || error instanceof DatabaseError) throw error;
      throw new DatabaseError(`Failed to fetch vulnerability: ${error}`);
    }
  }

  /**
   * Create multiple vulnerabilities
   */
  async createMany(vulnerabilities: CreateVulnerability[]): Promise<Vulnerability[]> {
    try {
      const { data, error } = await this.client
        .from("vulnerabilities")
        .insert(vulnerabilities)
        .select();

      if (error) {
        throw new DatabaseError(error.message);
      }

      return data || [];
    } catch (error) {
      if (error instanceof DatabaseError) throw error;
      throw new DatabaseError(`Failed to create vulnerabilities: ${error}`);
    }
  }

  /**
   * Get vulnerability statistics
   */
  async getStats(): Promise<{
    total: number;
    high: number;
    medium: number;
    low: number;
    info: number;
  }> {
    try {
      const { data, error } = await this.client
        .from("vulnerabilities")
        .select("severity");

      if (error) {
        throw new DatabaseError(error.message);
      }

      const stats = {
        total: data?.length || 0,
        high: 0,
        medium: 0,
        low: 0,
        info: 0,
      };

      data?.forEach((item) => {
        if (item.severity in stats) {
          stats[item.severity as keyof typeof stats]++;
        }
      });

      return stats;
    } catch (error) {
      if (error instanceof DatabaseError) throw error;
      throw new DatabaseError(`Failed to fetch statistics: ${error}`);
    }
  }

  /**
   * Delete vulnerability by ID
   */
  async deleteById(id: string): Promise<void> {
    try {
      const { error } = await this.client
        .from("vulnerabilities")
        .delete()
        .eq("id", id);

      if (error) {
        throw new DatabaseError(error.message);
      }
    } catch (error) {
      if (error instanceof DatabaseError) throw error;
      throw new DatabaseError(`Failed to delete vulnerability: ${error}`);
    }
  }

  /**
   * Test connection
   */
  async testConnection(): Promise<boolean> {
    const result = await databaseClient.testConnection();
    return result.success;
  }
}
